<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" >
    <head></head>
    <body>
        <h1 id="liquibase-best-practices">Liquibase Best Practices</h1>
        <p>This page describes a number of best practices that you can apply on your project.</p>
        <h2 id="organizing-your-changelogs">Organizing your changeLogs</h2>
        <p>The most common way to organize your changelogs is by major release. Choose a package in your classpath to store the changelogs, preferably near your database access classes. In this example, we will use com/example/db/changelog</p>
        <h3 id="directory-structure">Directory Structure</h3>
        <figure class="highlight"><pre xml:space="preserve"><code class="language-text" data-lang="text">    com
      example
        db
          changelog
            db.changelog-master.xml
            db.changelog-1.0.xml
            db.changelog-1.1.xml
            db.changelog-2.0.xml
          DatabasePool.java
          AbstractDAO.java</code></pre>
        </figure>
        <h3 id="dbchangelog-masterxml">db.changelog-master.xml</h3>
        <p>The master.xml includes the changelog for the releases in the correct order. In the example above it could look like this:</p>
        <figure class="highlight"><pre xml:space="preserve"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>   
<span class="nt">&lt;databaseChangeLog</span>  
  <span class="na">xmlns=</span><span class="s">"http://www.liquibase.org/xml/ns/dbchangelog"</span>  
  <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>  
  <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd"</span><span class="nt">&gt;</span>  

  <span class="nt">&lt;include</span>  <span class="na">file=</span><span class="s">"com/example/db/changelog/db.changelog-1.0.xml"</span><span class="nt">/&gt;</span>   
  <span class="nt">&lt;include</span>  <span class="na">file=</span><span class="s">"com/example/db/changelog/db.changelog-1.1.xml"</span><span class="nt">/&gt;</span>   
  <span class="nt">&lt;include</span>  <span class="na">file=</span><span class="s">"com/example/db/changelog/db.changelog-2.0.xml"</span><span class="nt">/&gt;</span>   
<span class="nt">&lt;/databaseChangeLog&gt;</span> </code></pre>
        </figure>
        <p>Each of the included XML files needs to be in the same format as a standard XML database change log, something like this:</p>
        <figure class="highlight"><pre xml:space="preserve"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>   
<span class="nt">&lt;databaseChangeLog</span>   
  <span class="na">xmlns=</span><span class="s">"http://www.liquibase.org/xml/ns/dbchangelog"</span>   
  <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>   
  <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd"</span><span class="nt">&gt;</span>   
  <span class="nt">&lt;changeSet</span>  <span class="na">author=</span><span class="s">"authorName"</span>  <span class="na">id=</span><span class="s">"changelog-1.0"</span><span class="nt">&gt;</span>  
    <span class="nt">&lt;createTable</span>  <span class="na">tableName=</span><span class="s">"TablesAndTables"</span><span class="nt">&gt;</span>  
      <span class="nt">&lt;column</span>  <span class="na">name=</span><span class="s">"COLUMN1"</span>  <span class="na">type=</span><span class="s">"TEXT"</span><span class="nt">&gt;</span>  
        <span class="nt">&lt;constraints</span>  <span class="na">nullable=</span><span class="s">"true"</span>  <span class="na">primaryKey=</span><span class="s">"false"</span>  <span class="na">unique=</span><span class="s">"false"</span><span class="nt">/&gt;</span>  
      <span class="nt">&lt;/column&gt;</span>  
    <span class="nt">&lt;/createTable&gt;</span>  
  <span class="nt">&lt;/changeSet&gt;</span>  
<span class="nt">&lt;/databaseChangeLog&gt;</span> </code></pre>
        </figure>
        <p>The db.changelog-master.xml is the changelog you pass to all Liquibase calls.</p>
        <h3 id="managing-stored-procedures">Managing Stored Procedures</h3>
        <p>Try to maintain separate changelog for Stored Procedures and use runOnChange=”true”. This flag forces LiquiBase to check if the changeset was modified. If so, liquibase executes the change again.</p>
        <h3 id="one-change-per-changeset">One Change per ChangeSet</h3>
        <p>As far as possible, Avoid multiple changes per changeset to avoid failed autocommit statements that can leave the database in an unexpected state.</p>
        <h2 id="changeset-ids">ChangeSet Ids</h2>
        <p>Choose what works for you. Some use a sequence number starting from 1 and unique within the changelog, some choose a descriptive name (e.g. ‘new-address-table’).</p>
        <h2 id="document-changesets">Document ChangeSets</h2>
        <p>Use <code class="highlighter-rouge">&lt;comments&gt;</code> in the change sets. They say “A stitch in time saves nine!”</p>
        <h2 id="always-think-about-rollback">Always think about rollback</h2>
        <p>Try to write changesets in a way that they can be rolled back. e.g. use relevant change clause instead of using custom <code class="highlighter-rouge">&lt;sql&gt;</code> tag.
Include a <code class="highlighter-rouge">&lt;rollback&gt;</code> clause whenever a change doesn’t support out of box rollback. (e.g. <code class="highlighter-rouge">&lt;sql&gt;</code>, <code class="highlighter-rouge">&lt;insert&gt;</code>, etc)</p>
        <h2 id="reference-data-management">Reference Data Management</h2>
        <p>Leverage Liquibase to manage your Reference Data. Environment separation (DEV, QA, PROD) can be achieved using “context”. <a href="https://www.liquibase.org/documentation/contexts.html">Learn about Liquibase contexts.</a></p>
        <h2 id="procedure-for-the-developer">Procedure for the developer</h2>
        <ul>
            <li>Using your favorite IDE or editor, create a new local changeSet containing the change;</li>
            <li>Run Liquibase to execute the new changeSet (this tests the SQL code);</li>
            <li>Perform the corresponding changes in the application code (e.g., Java code);</li>
            <li>Test the new application code together with the database change;</li>
            <li>Commit both the changeSet and the application code.</li>
        </ul>
        <h2 id="using-liquibase-to-achieve-cicd-for-databases">Using Liquibase to Achieve CI/CD for Databases</h2>
        <p>Database schema migrations are an essential task for every software project. <a href="http://www.liquibase.org/cicd-for-databases.html">Learn how to integrate Liquibase into your process to achieve CI/CD for databases</a>.</p>
        <h2 id="consider-liquibase-pro-or-datical">Consider Liquibase Pro or Datical</h2>
        <h3 id="liquibase-pro">Liquibase Pro</h3>
        <p><a href="https://download.liquibase.org/" target="_blank">Liquibase Pro</a> offers an extra layer of support so you don’t have to go it alone. While Liquibase is a great starting point, teams that want best practices on how to make the most of Liquibase may find Liquibase Pro better suited to their needs. Liquibase Pro also adds features like <a href="https://www.liquibase.org/documentation/rollbackonechangeset.html">Targeted Rollback</a> and the ability to work with <a href="https://www.liquibase.org/documentation/changes/index.html">Stored Logic</a>.</p>
        <h3 id="datical">Datical</h3>
        <p>Datical is a commercial product which builds on the core Liquibase functionality. Beyond versioning and managing database changes, Datical bridges the gap between development and operations with capabilities that enable a fully unified and automated path for database code.</p>
        <ul>
            <li>Datical has a web interface, command line interface, and REST API. All interfaces are secure and require authentication.</li>
            <li>Datical automatically verifies database code against organizational standards to eliminate manual review</li>
            <li>Datical automatically generates changesets from validated DDL code, eliminating manual effort in crafting changesets and manually updating the changelog</li>
            <li>Datical generates an immutable artifact for database code for consistent, repeatable, and automation-ready downstream deployments</li>
            <li>Datical forecasts the impact of database changes with an object-based model of the target database to ensure that there are no errors or issues when deploying database changes</li>
            <li>Datical integrates with ticketing systems such as JIRA to make it easy to trace database changes back to source code and initial requirements. This same capability also makes it easy to hold or accelerate feature sets.</li>
            <li>Datical can snapshot and compare database schemas to help identify and address drift</li>
        </ul>
        <p>For more information on Datical, visit <a href="https://www.datical.com/liquibase/" target="_blank" onclick="trackOutboundLink(this, 'Datical', 'Liquibase RFI'); return false">https://www.datical.com/Liquibase</a></p>
    </body>
</html>